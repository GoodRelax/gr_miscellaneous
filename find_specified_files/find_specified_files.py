# Copyright (c) 2025 GoodRelax
# MIT License
# This code was generated by ChatGPT-4o based on specifications provided by GoodRelax.

# ----------------------------------------------------------------------------------
# Specification and Usage:
#
# This script searches files and directories recursively based on patterns specified
# in an input file. Each line of the input file represents a search pattern using wildcards.
#
# Wildcards:
#   ? : Any single character
#   * : Any characters (zero or more)
#
# Wildcards match against both filenames and directory names.
# Matching is case-insensitive.
#
# Relative paths start searching from the current directory.
# Absolute paths start searching from the root directory.
#
# Usage Example:
#   py find_specified_files.py target.txt
#   py find_specified_files.py -dir-only target.txt     -dir-only : extract only directories
#
# Input file example (target.txt):
#   .\tool\*\*.py
#   .\data\*\*.json
#   .\docs\json_handling\*\0??_*.md
# ----------------------------------------------------------------------------------

import sys
import os
import fnmatch
import datetime


SLASH = "/"
REVERSE_SOLIDUS = "\\"
EMPTY_LINE = ""
HORIZONTAL_TAB = "\t"
DEFAULT_ENCODING = "cp932"
DATETIME_FORMAT = "%Y/%m/%d %H:%M:%S"

def unify_path(path):
    return os.path.abspath(path).replace(REVERSE_SOLIDUS, SLASH).lower()

def get_search_base(pattern):
    unified_pattern = pattern.replace(REVERSE_SOLIDUS, SLASH)
    parts = unified_pattern.split(SLASH)
    base_parts = []
    for part in parts:
        if "*" in part or "?" in part:
            break
        base_parts.append(part)
    base_dir = SLASH.join(base_parts)
    return base_dir if base_dir else "."

def get_size(path):
    if os.path.isfile(path):
        return os.path.getsize(path)
    total_size = 0
    for dirpath, _, filenames in os.walk(path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def find_files(pattern_list, directories_only=False):
    results = []
    for pattern in pattern_list:
        pattern = pattern.strip()
        if pattern == EMPTY_LINE:
            continue

        unified_pattern = unify_path(pattern)
        search_base = get_search_base(pattern)

        if not os.path.exists(search_base):
            continue

        for root, dirs, files in os.walk(search_base):
            targets = dirs if directories_only else dirs + files
            for entry in targets:
                full_path = os.path.abspath(os.path.join(root, entry))
                unified_full_path = unify_path(full_path)
                if fnmatch.fnmatch(unified_full_path, unified_pattern):
                    mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(full_path))
                    formatted_time = mod_time.strftime(DATETIME_FORMAT)
                    size = get_size(full_path)
                    results.append((formatted_time, size, full_path))

    unique_results = sorted(set(results))
    return unique_results

def main():
    if len(sys.argv) not in [2, 3]:
        print("Usage: py find_specified_files.py [-dir-only] target.txt")
        sys.exit(1)

    directories_only = False
    if len(sys.argv) == 3:
        if sys.argv[1] == "-dir-only":
            directories_only = True
            input_file = sys.argv[2]
        else:
            print("Invalid option.")
            print("Usage: py find_specified_files.py [-dir-only] target.txt")
            sys.exit(1)
    else:
        input_file = sys.argv[1]

    if not os.path.exists(input_file):
        print("File not found: " + input_file)
        sys.exit(1)

    with open(input_file, "r", encoding=DEFAULT_ENCODING) as f:
        patterns = f.readlines()

    files = find_files(patterns, directories_only=directories_only)
    # print("date" + HORIZONTAL_TAB + "size" + HORIZONTAL_TAB + "file")
    for formatted_time, size, path in files:
        try:
            print(formatted_time + HORIZONTAL_TAB + str(size) + HORIZONTAL_TAB + path)
        except UnicodeEncodeError:
            print(formatted_time + HORIZONTAL_TAB + str(size) + HORIZONTAL_TAB + path.encode(DEFAULT_ENCODING, errors="replace").decode(DEFAULT_ENCODING))

if __name__ == "__main__":
    main()
