<!DOCTYPE html>
<html lang="en">
	
	<head>
		<meta charset="UTF-8">
		<title>GR Simple Markdown and Mermaid Render</title>
		<style>
			body {
				margin: 0;
				font-family: sans-serif;
				display: flex;
				flex-direction: column;
				height: 100vh;
			}
			
			/* --- Top Bar Layout --- */
			#topbar {
				display: flex;
				align-items: center;
				padding: 8px 12px;
				background: #f0f0f0;
				gap: 16px;
				border-bottom: 1px solid #ccc;
			}
			
			/* Title & Copyright Group */
			#header-group {
				display: flex;
				flex-direction: column;
				justify-content: center;
				flex-shrink: 0;
			}
			
			#title {
				font-weight: bold;
				font-size: 16px;
				line-height: 1.2;
				white-space: nowrap;
			}
			
			#copyright {
				font-size: 10px;
				line-height: 1.2;
				margin-top: 2px;
			}
			
			#copyright a {
				color: blue;
				text-decoration: underline;
			}
			
			/* Controls (Buttons) */
			#controls {
				display: flex;
				gap: 8px;
				flex-shrink: 0;
			}
			
			/* Editor (Input Area) */
			#editor {
				flex: 1;
				font-family: monospace;
				font-size: 14px;
				padding: 4px 8px;
				border: 1px solid #ccc;
				height: 24px;
				min-height: 24px;
				resize: vertical;
				white-space: pre;
				overflow-y: auto;
			}
			
			/* Help Button */
			#helpBtn {
				flex: 0 0 24px;
				height: 34px;
				cursor: pointer;
				font-weight: bold;
				padding: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				-webkit-user-select: none;
				-moz-user-select: none;
				user-select: none;
			}
			
			/* --- Preview Area --- */
			#preview {
				flex: 1;
				overflow: auto;
				padding: 20px;
			}
			
			/* Markdown Elements */
			pre {
				background: #f4f4f4;
				padding: 12px;
				border-radius: 4px;
				overflow-x: auto;
			}
			
			blockquote {
				border-left: 4px solid #ccc;
				margin: 0;
				padding-left: 16px;
				color: #666;
			}
			
			/* Mermaid Container */
			.mermaid {
				display: flex;
				justify-content: center;
				margin: 16px 0;
			}
			
			/* PlantUML Error Display */
			.plantuml-error {
				border: 2px dashed #ff6b6b;
				padding: 12px;
				margin: 8px 0;
				border-radius: 4px;
				background-color: #fff5f5;
				color: #c92a2a;
				font-family: monospace;
				font-size: 13px;
			}
			
			/* --- Modal Styles --- */
			.modal {
				display: none;
				position: fixed;
				z-index: 1000;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				overflow: auto;
				background-color: rgba(0, 0, 0, 0.6);
			}
			
			.modal-content {
				background-color: #fefefe;
				margin: 5% auto;
				padding: 20px 30px;
				border: 1px solid #888;
				width: 80%;
				max-width: 700px;
				border-radius: 8px;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
				line-height: 1.6;
			}
			
			.close-btn {
				color: #aaa;
				float: right;
				font-size: 28px;
				font-weight: bold;
				cursor: pointer;
				line-height: 1;
			}
			
			.close-btn:hover,
			.close-btn:focus {
				color: black;
				text-decoration: none;
				cursor: pointer;
			}
			
			.modal-section {
				margin-bottom: 24px;
			}
			
			.modal-section h3 {
				margin-bottom: 8px;
				border-bottom: 1px solid #ddd;
				padding-bottom: 4px;
			}
			
			.modal-section ul {
				margin-top: 8px;
				padding-left: 20px;
			}
			
			/* Prompt Modal Textarea */
			#promptText {
				background: #f4f4f4;
				border: 1px solid #ccc;
				color: #333;
			}
			
			/* --- Dark Theme --- */
			body.dark {
				background: #222;
				color: #ddd;
			}
			
			.dark #topbar {
				background: #333;
				border-bottom: 1px solid #444;
			}
			
			.dark #editor {
				background: #444;
				color: #fff;
				border-color: #666;
			}
			
			.dark pre {
				background: #333;
				border: 1px solid #555;
			}
			
			.dark #copyright a {
				color: #66b3ff;
			}
			
			.dark .modal-content {
				background-color: #333;
				color: #eee;
				border: 1px solid #555;
			}
			
			.dark .close-btn {
				color: #ddd;
			}
			
			.dark .close-btn:hover {
				color: #fff;
			}
			
			.dark .modal-section h3 {
				border-bottom-color: #555;
			}
			
			.dark #promptText {
				background: #444;
				border: 1px solid #666;
				color: #fff;
			}
			
			.dark .plantuml-error {
				background-color: #2d1f1f;
				color: #ff8787;
				border-color: #ff6b6b;
			}
		</style>
		
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
		
	</head>
	
	<body>
		<div id="topbar">
			
			<div id="header-group">
				<div id="title">GR Simple MD MM Render</div>
				<div id="copyright">
					&copy; 2026 GoodRelax. MIT License.
					<br>
					<a href="https://github.com/GoodRelax" target="_blank">https://github.com/GoodRelax</a>
				</div>
			</div>
			
			<div id="controls">
				<button id="renderLight">Render Light</button>
				<button id="renderDark">Render Dark</button>
				<button id="newTabBtn">New Tab</button>
				<button id="clearBtn">Clear</button>
			</div>
			
			<textarea id="editor" placeholder="Paste Markdown..."></textarea>
			<button id="helpBtn" title="Help">?</button>
		</div>
		
		<div id="preview"></div>
		
		<!-- Help Modal -->
		<div id="helpModal" class="modal">
			<div class="modal-content">
				<span class="close-btn">&times;</span>
				
				<div class="modal-section">
					<h3>English</h3>
					<p><strong>Intent:</strong><br>
						This tool is a lightweight, privacy-conscious renderer for Markdown, Mermaid, and PlantUML. It runs entirely in your browser (client-side), ensuring your text remains local unless you explicitly allow external rendering of PlantUML.</p>
					
					<p><strong>How to Use:</strong></p>
					<ul>
						<li>Paste your Markdown text into the input field at the top.</li>
						<li>Click Render Light or Render Dark to generate the preview.</li>
						<li>Note on PlantUML: If your code contains PlantUML, you will be asked for permission to send data to the official PlantUML server. If you deny, the input will be cleared for security.</li>
					<li>Press and hold the (?) icon to obtain a prompt useful for generating Markdown with AI.</li>
					</ul>
				</div>
				
				<div class="modal-section">
					<h3>Japanese</h3>
					<p><strong>ÊÑèÂõ≥:</strong><br>
						Êú¨„ÉÑ„Éº„É´„ÅØ„ÄÅMarkdown„ÄÅMermaid„ÄÅPlantUML„ÅÆ„Åü„ÇÅ„ÅÆËªΩÈáè„Åã„Å§„Éó„É©„Ç§„Éê„Ç∑„Éº„ÇíÈáçË¶ñ„Åó„Åü„É¨„É≥„ÉÄ„É©„Éº„Åß„Åô„ÄÇ„Éñ„É©„Ç¶„Ç∂‰∏äÔºà„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„ÉâÔºâ„ÅÆ„Åø„ÅßÂãï‰Ωú„Åô„Çã„Åü„ÇÅ„ÄÅPlantUML„ÅÆÂ§ñÈÉ®„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíË®±ÂèØ„Åó„Å™„ÅÑÈôê„Çä„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Éá„Éº„Çø„ÅåÂ§ñÈÉ®„Å´ÈÄÅ‰ø°„Åï„Çå„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
					<p><strong>‰Ωø„ÅÑÊñπ:</strong></p>
					<ul>
						<li>‰∏äÈÉ®„ÅÆÂÖ•ÂäõÊ¨Ñ„Å´Markdown„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë„Åæ„Åô„ÄÇ</li>
						<li>Render Light „Åæ„Åü„ÅØ Render Dark „Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ</li>
						<li>PlantUML„Å´Èñ¢„Åô„ÇãÊ≥®ÊÑè: PlantUML„ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÄÅÂÖ¨Âºè„Çµ„Éº„Éê„Éº„Å∏„ÅÆ„Éá„Éº„ÇøÈÄÅ‰ø°„ÅÆË®±ÂèØ„ÇíÊ±Ç„ÇÅ„Çâ„Çå„Åæ„Åô„ÄÇ„Äå„Ç≠„É£„É≥„Çª„É´„Äç„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà„ÄÅ„Çª„Ç≠„É•„É™„ÉÜ„Ç£‰øùË≠∑„ÅÆ„Åü„ÇÅÂÖ•Âäõ„Éá„Éº„Çø„ÅØÂç≥Â∫ß„Å´Ê∂àÂéª„Åï„Çå„Åæ„Åô„ÄÇ</li>
					<li>(?)„Ç¢„Ç§„Ç≥„É≥„ÇíÈï∑Êäº„Åó„Åô„Çã„Å®„ÄÅAI„ÅßMarkdown„ÇíÁîüÊàê„Åô„Çã„ÅÆ„Å´ÂΩπÁ´ã„Å§„Éó„É≠„É≥„Éó„Éà„ÇíÂèñÂæó„Åß„Åç„Åæ„Åô</li>
					</ul>
				</div>
			</div>
		</div>
		
		<!-- Prompt Modal -->
		<div id="promptModal" class="modal">
			<div class="modal-content">
				<span class="close-btn prompt-close">&times;</span>
				<div class="modal-section">
					<h3>Prompt for AI Markdown Generation</h3>
					<p>The prompt below improves the quality of the AI‚Äôs Markdown output by reducing errors. Simply copy and paste it to use</p>
					
					<textarea id="promptText" readonly style="width: 100%; height: 200px; margin-bottom: 10px; resize: none; font-family: monospace; font-size: 12px; padding: 8px; box-sizing: border-box;"></textarea>
					<button id="copyPromptBtn" style="width: 100%; padding: 10px; cursor: pointer; font-weight: bold;">Copy to Clipboard</button>
				</div>
			</div>
		</div>
		
		
		<script type="module">
			// ========================================
			// External Imports
			// ========================================
			import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
			import hljs from 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/es/highlight.min.js';
			import plantumlEncoder from 'https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/+esm';
			
			
			// ========================================
			// Class: ApplicationState
			// ========================================
			class ApplicationState {
				constructor() {
					this.currentTheme = 'light';
					this.markdownText = '';
				}
				
				setTheme(theme) {
					this.currentTheme = theme;
				}
				
				setMarkdownText(text) {
					this.markdownText = text;
				}
			}
			
			
			// ========================================
			// Class: ScrollManager
			// ========================================
			class ScrollManager {
				constructor(container) {
					this.container = container;
				}
				
				save() {
					return this.container.scrollTop;
				}
				
				restore(scrollTop) {
					this.container.scrollTop = scrollTop;
				}
			}
			
			
			// ========================================
			// Class: DOMStabilityWatcher
			// ========================================
			class DOMStabilityWatcher {
				/**
				 * Wait for DOM to become stable using ResizeObserver
				 * Event-driven: completes when element has no resize for 50ms
				 * Timeout: continues after specified duration if still unstable
				 * 
				 * @param {HTMLElement} element - Element to watch
				 * @param {number} timeout - Maximum wait time in milliseconds (default: 1000)
				 * @returns {Promise<boolean>} - true if stable, false if timeout
				 */
				static async waitForStability(element, timeout = 1000) {
					return new Promise((resolve) => {
						let resizeTimer;
						let timeoutTimer;
						
						const resizeObserver = new ResizeObserver(() => {
							// Element resized - reset stability timer
							clearTimeout(resizeTimer);
							resizeTimer = setTimeout(() => {
								// No resize for 50ms - considered stable
								cleanup();
								resolve(true);
							}, 50);
						});
						
						const cleanup = () => {
							resizeObserver.disconnect();
							clearTimeout(resizeTimer);
							clearTimeout(timeoutTimer);
						};
						
						// Start observing
						resizeObserver.observe(element);
						
						// Timeout fallback
						timeoutTimer = setTimeout(() => {
							cleanup();
							console.warn('DOM stability timeout after', timeout, 'ms (continuing anyway)');
							resolve(false);
						}, timeout);
					});
				}
			}
			
			
			// ========================================
			// Class: MarkdownRenderer
			// ========================================
			class MarkdownRenderer {
				constructor(preview, marked, hljs) {
					this.preview = preview;
					this.marked = marked;
					this.hljs = hljs;
				}
				
				/**
				 * Render Markdown with syntax highlighting
				 * @param {string} markdownText
				 * @returns {Promise<void>}
				 */
				async render(markdownText) {
					try {
						const html = this.marked.parse(markdownText);
						this.preview.innerHTML = html;
						
						// Apply syntax highlighting (synchronous)
						try {
							this.hljs.highlightAll();
						} catch (hljsError) {
							console.error('Syntax highlighting error:', hljsError);
						}
						
					} catch (error) {
						console.error('Markdown parse error:', error);
						this.preview.innerHTML = `<pre style="color: red;">Markdown Parse Error: ${error.message}</pre>`;
					}
				}
			}
			
			
			// ========================================
			// Class: DiagramRenderer (Interface)
			// ========================================
			class DiagramRenderer {
				/**
				 * Render diagram with theme
				 * @param {string} theme - 'light' or 'dark'
				 * @returns {Promise<void>}
				 */
				async render(theme) {
					throw new Error('DiagramRenderer.render() must be implemented');
				}
			}
			
			
			// ========================================
			// Class: MermaidRenderer
			// ========================================
			class MermaidRenderer extends DiagramRenderer {
				constructor(preview, mermaid) {
					super();
					this.preview = preview;
					this.mermaid = mermaid;
				}
				
				/**
				 * Render all Mermaid diagrams
				 * @param {string} theme
				 * @returns {Promise<void>}
				 */
				async render(theme) {
					try {
						const mermaidBlocks = this.preview.querySelectorAll('code.language-mermaid');
						
						if (mermaidBlocks.length === 0) {
							return;
						}
						
						// Convert code blocks to mermaid containers
						mermaidBlocks.forEach(block => {
							const container = document.createElement('div');
							container.className = 'mermaid';
							container.textContent = block.textContent;
							
							const pre = block.parentElement;
							if (pre && pre.tagName === 'PRE') {
								pre.replaceWith(container);
							} else {
								block.replaceWith(container);
							}
						});
						
						this.mermaid.initialize({
							startOnLoad: false,
							theme: theme === 'dark' ? 'dark' : 'default'
						});
						
						await this.mermaid.run({
							nodes: this.preview.querySelectorAll('.mermaid')
						});
						
					} catch (error) {
						console.error('Mermaid rendering error:', error);
					}
				}
			}
			
			
			// ========================================
			// Class: PlantUMLRenderer
			// ========================================
			class PlantUMLRenderer extends DiagramRenderer {
				constructor(preview, plantumlEncoder) {
					super();
					this.preview = preview;
					this.encoder = plantumlEncoder;
				}
				
				/**
				 * Render all PlantUML diagrams
				 * @param {string} theme
				 * @returns {Promise<void>}
				 */
				async render(theme) {
					try {
						const plantumlBlocks = this.preview.querySelectorAll('code.language-plantuml');
						
						if (plantumlBlocks.length === 0) {
							return;
						}
						
						const imageLoadPromises = [];
						
						plantumlBlocks.forEach(block => {
							try {
								let code = block.textContent;
								
								// Inject dark theme
								if (theme === 'dark' && !code.includes('!theme')) {
									code = code.replace(/(@start\w+.*)/i, '$1\n!theme cyborg');
								}
								
								const encoded = this.encoder.encode(code);
								const url = `https://www.plantuml.com/plantuml/svg/${encoded}`;
								
								const img = document.createElement('img');
								img.src = url;
								img.alt = "PlantUML Diagram";
								img.style.maxWidth = "100%";
								
								// Wait for image load (5s timeout)
								const loadPromise = this.waitForImageLoad(img, 5000);
								imageLoadPromises.push(loadPromise);
								
								const pre = block.parentElement;
								if (pre && pre.tagName === 'PRE') {
									pre.replaceWith(img);
								} else {
									block.replaceWith(img);
								}
								
							} catch (error) {
								console.error('PlantUML encoding error:', error);
								const errorDiv = this.createErrorElement('PlantUML encoding failed');
								const pre = block.parentElement;
								if (pre && pre.tagName === 'PRE') {
									pre.replaceWith(errorDiv);
								} else {
									block.replaceWith(errorDiv);
								}
							}
						});
						
						// Wait for all images
						await Promise.allSettled(imageLoadPromises);
						
					} catch (error) {
						console.error('PlantUML rendering error:', error);
					}
				}
				
				/**
				 * Wait for image load with timeout
				 * @param {HTMLImageElement} img
				 * @param {number} timeout
				 * @returns {Promise<boolean>}
				 */
				async waitForImageLoad(img, timeout = 5000) {
					return new Promise((resolve) => {
						const timer = setTimeout(() => {
							const errorDiv = this.createErrorElement('PlantUML timeout (5s)');
							img.replaceWith(errorDiv);
							resolve(false);
						}, timeout);
						
						img.onload = () => {
							clearTimeout(timer);
							resolve(true);
						};
						
						img.onerror = () => {
							clearTimeout(timer);
							const errorDiv = this.createErrorElement('PlantUML server error');
							img.replaceWith(errorDiv);
							resolve(false);
						};
					});
				}
				
				/**
				 * Create error display element
				 * @param {string} message
				 * @returns {HTMLElement}
				 */
				createErrorElement(message) {
					const errorDiv = document.createElement('div');
					errorDiv.className = 'plantuml-error';
					errorDiv.textContent = message;
					return errorDiv;
				}
			}
			
			
			// ========================================
			// Class: RendererOrchestrator
			// ========================================
			class RendererOrchestrator {
				constructor(state, markdownRenderer, diagramRenderers, scrollManager, preview) {
					this.state = state;
					this.markdownRenderer = markdownRenderer;
					this.diagramRenderers = diagramRenderers;
					this.scrollManager = scrollManager;
					this.preview = preview;
				}
				
				/**
				 * Execute all rendering steps with parallel diagram rendering
				 * @returns {Promise<void>}
				 */
				async renderAll() {
					try {
						const scrollTop = this.scrollManager.save();
						
						// Markdown includes syntax highlighting
						await this.markdownRenderer.render(this.state.markdownText);
						
						// Diagrams execute in parallel
						const diagramResults = await Promise.allSettled(
							this.diagramRenderers.map(renderer => renderer.render(this.state.currentTheme))
						);
						
						// Log failures but continue
						diagramResults.forEach((result, index) => {
							if (result.status === 'rejected') {
								console.error(`Diagram renderer ${index} failed:`, result.reason);
							}
						});
						
						// Wait for DOM stability (ResizeObserver + timeout)
						await DOMStabilityWatcher.waitForStability(this.preview, 1000);
						
						// Restore scroll position
						this.scrollManager.restore(scrollTop);
						
					} catch (error) {
						console.error('Rendering orchestration error:', error);
						// Best-effort: attempt scroll restore even on catastrophic error
					}
				}
			}
			
			
			// ========================================
			// Initialization and Event Handlers
			// ========================================
			
			// DOM Elements
			const editor = document.getElementById('editor');
			const preview = document.getElementById('preview');
			const renderLightBtn = document.getElementById('renderLight');
			const renderDarkBtn = document.getElementById('renderDark');
			const newTabBtn = document.getElementById('newTabBtn');
			const clearBtn = document.getElementById('clearBtn');
			
			// Modal Elements
			const helpModal = document.getElementById('helpModal');
			const helpBtn = document.getElementById('helpBtn');
			const closeSpan = document.getElementsByClassName('close-btn')[0];
			const promptModal = document.getElementById('promptModal');
			const promptClose = document.querySelector('.prompt-close');
			const promptText = document.getElementById('promptText');
			const copyPromptBtn = document.getElementById('copyPromptBtn');
			
			// Helper function
			function hasPlantUML(text) {
				return /```plantuml/i.test(text) || /@startuml/i.test(text);
			}
			
			// Initialize application components
			const state = new ApplicationState();
			const scrollManager = new ScrollManager(preview);
			const markdownRenderer = new MarkdownRenderer(preview, marked, hljs);
			const mermaidRenderer = new MermaidRenderer(preview, mermaid);
			const plantumlRenderer = new PlantUMLRenderer(preview, plantumlEncoder);
			const orchestrator = new RendererOrchestrator(
				state,
				markdownRenderer,
				[mermaidRenderer, plantumlRenderer],
				scrollManager,
				preview
			);
			
			// Prompt text content
			const COPY_PAYLOAD = `
## Output Format
- Output the entire content as a single Markdown document so it can be copied at once.
- Enclose the entire Markdown with six backticks \` \`\`\`\`\`\` \` at the beginning and end. Specify its language as markdown.
- Use the six backticks only once as the outermost enclosure.
- Any UML diagrams or software code inside the Markdown must each be enclosed in their own code blocks using three backticks \` \`\`\` \`.
  This creates a structure where multiple three backticks blocks are nested inside the outer six backticks block to prevent Markdown splitting.
- For each UML diagram or source code block, output the following line exactly two lines above it:
 **contents_name:**
- Prefix each inner code block with a language or file type, for example: \` \`\`\`python \`
- As a rule, use Mermaid for UML diagrams. Use PlantUML only when Mermaid cannot represent the diagram.
- Use only alphanumeric characters and underscores \`_\` in UML.  
- Write explanations only outside UML blocks, and placed immediately after the corresponding UML but within the Markdown.
- Output all required UML contents completely, without omission.
- All arrows and relationship lines in UML diagrams (including dashed lines and bidirectional links) must have labels, and the following notation rules must be strictly followed:
  1. For Mermaid \`flowchart\` and \`graph\`: include the label inside the arrow definition using pipes  
     (example: \`A -->|Label| B\`)
  2. For all other Mermaid diagrams and all PlantUML diagrams: include the label at the end using a colon  
     (example: \`A --> B : Label\`)
- This method is called **MCBSMD** (Multiple Code Block in Single MarkDown).
`;
			
			if (promptText) promptText.value = COPY_PAYLOAD;
			
			
			// ========================================
			// Event Handlers: Render Buttons
			// ========================================
			
			renderLightBtn.addEventListener('click', async () => {
				const content = editor.value;
				
				// PlantUML security check (UI layer)
				if (hasPlantUML(content)) {
					const agreed = window.confirm(
						`Security & Confidentiality Warning\n\n` +
						`Your data will be sent to an external PlantUML server to create diagrams.\n\n` +
						`Your Markdown -- [OK]‚Üí üåê\n\n` +
						`Do you want to continue?`
					);
					
					if (!agreed) {
						editor.value = '';
						preview.innerHTML = '';
						document.body.classList.remove('dark');
						return;
					}
				}
				
				state.setTheme('light');
				state.setMarkdownText(content);
				document.body.classList.remove('dark');
				
				await orchestrator.renderAll();
			});
			
			renderDarkBtn.addEventListener('click', async () => {
				const content = editor.value;
				
				// PlantUML security check (UI layer)
				if (hasPlantUML(content)) {
					const agreed = window.confirm(
						`Security & Confidentiality Warning\n\n` +
						`Your data will be sent to an external PlantUML server to create diagrams.\n\n` +
						`Your Markdown -- [OK]‚Üí üåê\n\n` +
						`Do you want to continue?`
					);
					
					if (!agreed) {
						editor.value = '';
						preview.innerHTML = '';
						document.body.classList.remove('dark');
						return;
					}
				}
				
				state.setTheme('dark');
				state.setMarkdownText(content);
				document.body.classList.add('dark');
				
				await orchestrator.renderAll();
			});
			
			
			// ========================================
			// Event Handlers: Utility Buttons
			// ========================================
			
			newTabBtn.addEventListener('click', () => {
				window.open(window.location.href, '_blank');
			});
			
			clearBtn.addEventListener('click', () => {
				editor.value = '';
				preview.innerHTML = '';
				document.body.classList.remove('dark');
			});
			
			
			// ========================================
			// Event Handlers: Help Button (Long Press)
			// ========================================
			
			let pressTimer;
			let isLongPress = false;
			
			function triggerLongPressAction() {
				isLongPress = true;
				if (promptModal) promptModal.style.display = "block";
			}
			
			function startPress(e) {
				if (e.type === 'mousedown' && e.button !== 0) return;
				isLongPress = false;
				pressTimer = setTimeout(triggerLongPressAction, 800);
			}
			
			function cancelPress(e) {
				clearTimeout(pressTimer);
			}
			
			function handleHelpClick(e) {
				if (isLongPress) {
					e.preventDefault();
					e.stopPropagation();
					isLongPress = false;
					return;
				}
				helpModal.style.display = "block";
			}
			
			// PC (Mouse)
			helpBtn.addEventListener('mousedown', startPress);
			helpBtn.addEventListener('mouseup', cancelPress);
			helpBtn.addEventListener('mouseleave', cancelPress);
			
			// Mobile (Touch)
			helpBtn.addEventListener('touchstart', (e) => {
				startPress(e);
			});
			helpBtn.addEventListener('touchend', (e) => {
				cancelPress(e);
				if (!isLongPress) {
					e.preventDefault();
					handleHelpClick(e);
				}
			});
			
			// Click event (PC fallback)
			helpBtn.addEventListener('click', (e) => {
				handleHelpClick(e);
			});
			
			
			// ========================================
			// Event Handlers: Copy Prompt Button
			// ========================================
			
			if (copyPromptBtn) {
				copyPromptBtn.addEventListener('click', () => {
					promptText.select();
					promptText.setSelectionRange(0, 99999);
					
					try {
						const successful = document.execCommand('copy');
						if (successful) {
							showCopySuccess();
						} else {
							alert("Copy failed.");
						}
					} catch (err) {
						alert("Browser denied copy.");
					}
				});
			}
			
			function showCopySuccess() {
				const originalText = copyPromptBtn.textContent;
				copyPromptBtn.textContent = "Copied!";
				
				setTimeout(() => {
					copyPromptBtn.textContent = originalText;
					copyPromptBtn.style.backgroundColor = "";
					promptModal.style.display = "none";
				}, 1000);
			}
			
			
			// ========================================
			// Event Handlers: Modal Close
			// ========================================
			
			closeSpan.onclick = function() {
				helpModal.style.display = "none";
			}
			
			if (promptClose) {
				promptClose.onclick = function() {
					promptModal.style.display = "none";
				}
			}
			
			window.onclick = function(event) {
				if (event.target == helpModal) {
					helpModal.style.display = "none";
				}
				if (event.target == promptModal) {
					promptModal.style.display = "none";
				}
			}
		</script>
		
	</body>
	
</html>
